= Arithmetic
:fn_commute: footnote:[https://en.wikipedia.org/wiki/Commutative_property]
:fn_neg: footnote:[https://en.wikipedia.org/wiki/Additive_inverse]
:fn_div: footnote:[https://en.wikipedia.org/wiki/Multiplicative_inverse]


WARNING: work in progress

// Unicode symbols:
//   https://unicode-table.com/en/sets/mathematical-signs/

.binary operations

,===
symbol, name of binary operation, commutative? {fn_commute}

+,addition, yes
×,multiplication, yes
,===

.unary inverses 

,===
symbol, name of binary operation, commutative? {fn_commute}, name of unary inverse 

−, substraction, no, negation {fn_neg}
÷, division, no, reciprocal {fn_div}
,===

Subtraction and divistion as binary operations aren't commutative,
  ie `a - b ≠ b - a` and `a ÷ b ≠ b ÷ a`.
That's why forward uses the unary operations (which are inverses);
so that we can't preserve the commutative property.

Why do we want to preserve the commutative property?
Because in stack-based languages,
one thing that often bothers me is having to manipulate the stack
so that things are in the right order.
By having preserving the commutative property,
we don't have to worry as much in what order things are on the stack.

[ditaa]
----
+-----------+       +-----------+
| + | a | b |   =   | + | b | a |
+-----------+       +-----------+

+-----------+       +-----------+
| × | a | b |   =   | × | b | a |
+-----------+       +-----------+

+-----------+       +-----------+
| − | a | b |   ≠   | − | b | a |
+-----------+       +-----------+

+-----------+       +-----------+
| ÷ | a | b |   ≠   | ÷ | b | a |
+-----------+       +-----------+

Using unary inverses instead:

+-------+
| − | a |
+-------+

+-------+
| ÷ | a |
+-------+

----




.interesting property of inverses
[sidebar]
negation "creates" the negative numbers, while
reciprocal "creates" fractions
