:subtitle: Boolean Algebras, VHDL, and forth
ifdef::env-github[:hardbreaks:]
:relfileprefix: ../
:dir: blog/
include::{relfileprefix}README.adoc[tag=preamble]

:relfileprefix:

== {subtitle}

.nand2tetris Figure 1.6
> link:https://creativecommons.org/licenses/by-nc-sa/3.0/[CC BY-NC-SA 3.0]

image::VHDL.png[]

=== HDL program

==== using graphiz

link:http://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0A%0Aa%20-%3E%20nota%20%23%20NOT%0Ab%20-%3E%20notb%20%23%20NOT%0A%0A%7Ba%20notb%7D%20-%3E%20w1%20%23%20AND%0A%7Bnota%20b%7D%20-%3E%20w2%20%23%20AND%0A%0A%7Bw1%20w2%7D%20-%3E%20out%20%23%20OR%0A%0A%7D%0A[graphiz playground]

[source,dot]
----
digraph G {

a -> nota # NOT
b -> notb # NOT

{a notb} -> w1 # AND
{nota b} -> w2 # AND

{w1 w2} -> out # OR

}
----

==== using a made-up DSL

taking inspiration from graphiz and forth

[source,factor]
----
:: xor ( a b -- out )
     a not :> nota
     b not :> notb

a notb and :> w1
nota b and :> w2

w1 w2  or  :> out
;
----

actually this is executable `factor` code, using
link:https://docs.factorcode.org/content/article-locals-examples.html[lexical variables],
so it isn't super "made-up".

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

****

here's the entire thing...

.without using intermediate variables: 

[source,factor]
----
:: xor ( a b -- out )
a b not and
b a not and
or
;
----

.without using any variables: 

[source,factor]
----
: xor ( a b -- out )
[      not and ]
[ swap not and ]
2bi
or
;
----

********

Note that `a` and `b` disappeared from the definition,
and are just left in the stack notation.
The stack notation can be thought of as being similar to
type signatures/annotations in other languages, eg:

[source,haskell]
----
xor :: a -> b -> out
----

In this example we manipulated the stack using the dataflow combinator `2bi`,
and the shuffle word `swap` (which has the stack effect `( a b -- b a )`)
  footnote:[2bi: https://docs.factorcode.org/content/word-2bi%2Ckernel.html]
  footnote:[shuffle words: https://docs.factorcode.org/content/article-shuffle-words.html]

********

.without using quotations: 

[source,factor]
----
: xor  ( a b -- out )
2dup ! ( a b -- a b a b )
    not and ! ( a b a b -- a b w1 )
-rot                   ! ( a b w1 -- w1 a b )
    swap                         ! ( w1 a b -- w1 b a )
    not and                                ! ( w1 b a -- w1 w2 )
    or
;
----

********

Here, instead of using `2bi` we have to use `2dup` to duplicate `a` and `b`,
 since we're going to use them twice.
We then use `-rot` to move `w1` out of the way for `[swap not and]`,
 only that this time they're not in a quotation.
Think of `2bi` as a higher-order function,
 and by using `2dup ... -rot`
 we remove the need for higher-order functions.
I tried to align the stack annotations to make clearer what is going on.

********

****

=== Test script

[source,factor]
----
: xor ( a b -- out ) [ not and ] [ swap not and ] 2bi or ;
----
