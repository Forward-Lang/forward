:subtitle: Composing grammars
:docinfo: shared
:relfileprefix: ../
include::{relfileprefix}README.adoc[tag=preamble]

:relfileprefix:

== {subtitle}

Parsers can be composed using parser combinators,
  footnote:[https://en.wikipedia.org/wiki/Parser_combinator]
but what about the grammars themselves?
How does that work?

toc::[]

=== From Wikipedia:

In the classic formalization of generative grammars first proposed by Noam Chomsky in the 1950s, a grammar ğ† consists of the following components:
  footnote:[https://en.wikipedia.org/wiki/Formal_grammar#The_syntax_of_grammars]

* A finite set ğ of nonterminal symbols, that is disjoint with the strings formed from ğ’.
* A finite set ğšº of terminal symbols that is disjoint from ğ.
* A finite set ğ of production rules, each rule of the form pass:[(ğšº âˆª ğ)* ğ (ğšº âˆª ğ)* â†’ (ğšº âˆª ğ)*]
where pass:[*] is the Kleene star operator and âˆª denotes set union. 
* A distinguished symbol ğ’ âˆˆ ğ that is the start symbol, also called the sentence symbol.

A grammar is formally defined as the tuple (ğ, ğšº, ğ, ğ’). 

---

=== Composing regular grammars

The first grammar ğ†: (ğ, ğšº, ğ, ğ’). 

* A finite set ğ = { ğ’ }.
* A finite set ğšº  = { a }.
* A finite set ğ of production rules, each rule of the form pass:[ğ â†’ (ğšº âˆª ğ)*]
footnote:[regular gammars have restrictions on the production rules]
** ğ’ -> a

This grammar defines the language L(ğ†) = { a^n^ | n = 1 } where a^n^ denotes a string of n consecutive a's.

The second grammar ğ†': (ğ', ğšº', ğ', ğ’'). 

* A finite set ğ' = { ğ’' }.
* A finite set ğšº'  = { b }.
* A finite set ğ' of production rules, each rule of the form pass:[ğ â†’ (ğšº âˆª ğ)*]
** ğ’' -> b

This grammar defines the language L(ğ†') = { b^n^ | n = 1 }.

Composing the two grammars:

 ğ† + ğ†': (ğ âˆª ğ', ğšº âˆª ğšº', ğ âˆª ğ', ???)

Since ğ, ğšº, and ğ are finite sets, the easiest thing to do is a union of the two grammars.
However ğ’, the start symbol, is supposed to be unique in the ğ set, ie there is only one starting point for a grammar.
That is at least a common underlying assumption.
So what do we do when we are trying to compose grammars, and end up with several starting symbols?

==== What to do with the Start symbols?

Since ğ’ is a nonterminal ğ, we can think in more abstract terms: what do we do when we have several nonterminals?
Well, we can concatenate them, or alternate them.
If we concatenate them we would say that the language has to start with both starting symbols. 
If we alternate them we would say that the language has to start with either starting symbol. 

But, what happens to the production rules, then? Since, they also include the starting symbols.
Well alternating them, would result in no needed changes to the existing production rules.
Whereas, concatenating, would introduce some interesting interactions with the existing production rules.
Consider a situation where we define ğ’'' as the "true" starting symbol:

----
# choosing to alternate starting symbols
ğ’'' â†’ ğ’' | ğ’              <1>
ğ’' â†’ b
ğ’ â†’ a

# choosing to concatenate starting symbols
ğ’'' â†’ ğ’' ğ’                <2>
ğ’' â†’ b
ğ’ â†’ a
----
<1> I'm mixing notations, using `|` as an explicit alternation operator,
even though normally it would be defined as `ğ’'' -> ğ’'` on one line and `ğ’'' -> ğ’` on the next.
<2> As we can see, writing it out, this is clearly equivalent to `ğ’'' â†’ b a`.
In other words, what happens when concatenating is that the order of the starting symbols affects the resulting language.

Ok, having observed the results of alternating or concatenating the starting symbols, what left is to denote the language.
The first grammar, the "alternation" grammar, defines the language `{ x^n^ | n = 1 ; x âˆˆ {a,b} }`.
  footnote:Operations[See and compare with https://en.wikipedia.org/wiki/Formal_language#Operations_on_languages]
The second grammar, the "concatenation" grammar, defines the language `{ b^n^a^n^ | n = 1 }`. 
  footnote:Operations[]
  
==== Attempt 2

Up until now, during the last section, we have been talking about the grammar in terms of the production rules.
However, before that we were also talking about the grammar in terms of a tuple.
Lets get back to that. This is what we had so far:

 ğ† + ğ†': (ğ âˆª ğ', ğšº âˆª ğšº', ğ âˆª ğ', ???)

Since ğ âˆª ğ' and ğ’ âˆˆ ğ the missing part has to be ğ’ âˆª ğ’'

 ğ† + ğ†': (ğ âˆª ğ', ğšº âˆª ğšº', ğ âˆª ğ', ğ’ âˆª ğ’')

If we state that `ğ’ = ğ’'` then we would get `ğ’ â†’ b` and `ğ’ â†’ a`, which is equivalent to the "alternation" grammar above.
  footnote:Operations[]

If we want the grammar tuple for the "concatenation" grammar above then perhaps this is it: 

----
ğ† + ğ†': (ğ âˆª ğ', ğšº âˆª ğšº', ğ âˆª ğ' âˆª ğ'', ğ’'')
where ğ'' = { ğ’'' â†’ ğ’' ğ’ }
and ğ’'' is the only starting symbol
----


****
include::2.1-incomplete-spec.adoc[lines=9..-1]
****
