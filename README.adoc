# forward
:toc:
:toc-placement!:

link:https://github.com/Bruno-366/forward/actions/workflows/asciidoctor-ghpages.yml[image:https://github.com/Bruno-366/forward/actions/workflows/asciidoctor-ghpages.yml/badge.svg[asciidoctor-ghpages]]

A stack-based programming language.
Powerful Enough, Simple, Correct.

[cols="h,a"]
|===========
| Mission | To create a programming language that is simple enough to be understood fully under a week, but with **powerful enough mental models** to allow for its effective use and application within different problem domains.
| Vision | That due to its simplicity it sees widespread use whithin its problem domains, remaining in the background, out of the way, ready to be used. Ubiquitous like the shell, but as effective as a scalpel, not a <<chainsaw>>! 
| Values |

* "Correct" mental mapping of models to the problem domains. (Once learnt,) it should stay out of the way, you should focus on solving your problem, not fixing your tools.
* Simplicity, through the removal of unnecessities. Being <<simplex>>, by choosing to untangle and compose concepts rather than to interleave them.
* "Simply Correct", easy to use tools to formally specify and verfiy implementations
* Fast (enough), no one likes a blunt, dull tool. Make it sharp, make it fast.

|===========

## Quotes

[quote, Antoine de Saint Exup√©ry]
In anything at all, perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away, when a body has been stripped down to its nakedness.

---

toc::[]

## Goals

* Literate programming
* Debugging
** Read Eval Print Loop
* Denotational semantics
* Axiomatic semantics
** <<Hoare>> triples: Pre- and Post-conditions. Possibly also while-conditions aka invariants.
** <<Dependent>> types
* Stupidly Simple Grammar
* Pattern Matching
** Macros
** Intuitive Grammar (on layer 2, after macros are applied)
** Code as Data, but not Data as Code.

### Inspiration sources

Currently being inspired mainly by:

* UI/UX of <<factor>>, <<pharo>> and especially <<r4>>
** Holistic approach of Lisp Machines, Oberon, Smalltalk, Forth
* Numerical semantics of <<APL>>
* Textual semantics of the unix shell.

## Grammar

Unfortunately stack-based/concatenative languages don't really have a grammar, as there is no syntax.
These languages are made up of words. 

## Denotational semantics


### Informal definitions

* Atoms/Elements:
** Booleans
** Characters
** Numbers
* Arrays
** Bitarrays
** Strings
** Vectors
** Matrixes

### Formal definitions



# <<Waterfall>> process | https://github.com/Bruno-366/forward/milestones?direction=asc&sort=title[Milestones]

. Integration Requirements
. Feature Design
. Properties
. Specification
. Implementation
. Verification
. Maintenance 



[bibliography]
= References

* [[[Hoare]]] https://en.wikipedia.org/wiki/Hoare_logic#Hoare_triple
* [[[Waterfall]]] https://en.wikipedia.org/wiki/Waterfall_model#Model
* [[[Dependent]]] https://en.wikipedia.org/wiki/Dependent_type
* [[[factor]]] https://github.com/factor/factor/
* [[[APL]]] https://tryapl.org/
* [[[pharo]]] https://github.com/pharo-project/pharo
* [[[r4]]] https://github.com/phreda4/r4
* [[[chainsaw]]] The Unix shell is sometimes referred to as a chainsaw (see `rm -rf *`)
* [[[simplex]]] https://www.infoq.com/presentations/Simple-Made-Easy/

+++
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This README is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.
+++
