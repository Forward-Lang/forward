# forward
:toc:
:toc-placement!:
:toclevels: 3

A stack-based programming language.
Powerful, Simple, Correct.

[cols="h,a"]
|===========
| Mission | To create a programming language that is simple enough to be understood fully under a week, but with powerful enough mental models to allow for its effective use and application within different problem domains.
| Vision | That due to its simplicity it sees widespread use whithin its problem domains, remaining in the background, out of the way, ready to be used. Ubiquitous like the shell, but as effective as a scalpel, not a <<chainsaw>>! 
| Values |

* "Correct" mental mapping of models to the problem domains. (Once learnt,) it should stay out of the way, you should focus on solving your problem, not fixing your tools.
* Simplicity, through the removal of unnecessities. Being <<simplex>>, by choosing to untangle and compose concepts rather than to interleave them.
* "Simply Correct", easy to use tools to formally specify and verfiy implementations
* Fast (enough), no one likes a blunt, dull tool. Make it sharp, make it fast.

|===========

## Quotes

[quote, Antoine de Saint Exup√©ry]
In anything at all, perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away, when a body has been stripped down to its nakedness.

---

toc::[]

## Goals

* Literate programming
* Debugging
** Read Eval Print Loop
* Denotational semantics
* Axiomatic semantics
** <<Hoare>> triples: Pre- and Post-conditions. Possibly also while-conditions aka invariants.
** <<Dependent>> types
* Stupidly Simple Grammar
* Pattern Matching
** Macros
** Intuitive Grammar (on layer 2, after macros are applied)
** Code as Data, but not Data as Code.

### Inspiration sources

Currently being inspired mainly by:

* UI/UX of <<factor>>, <<pharo>> and especially <<r4>>
** Holistic approach of Lisp Machines, Oberon, Smalltalk, Forth
* Numerical semantics of <<APL>>
* Textual semantics of the unix shell.

## Grammar

Whether stack-based/concatenative languages have grammars is a bit unclear, due to 2 main reasons:
1) most, if not all, of the program is made of space-delimited words/tokens
2) the parsing of stack-based languages can often be extended at runtime. 
So supposedly, due to the aforementioned reasons, forth doesn't really have a grammar, as there is no syntax.
  footnote:[https://softwareengineering.stackexchange.com/questions/370518/why-does-forths-flexibility-make-a-grammar-inappropriate-for-it]
  footnote:[https://groups.google.com/g/comp.lang.forth/c/nbVrIzbafKM]
  footnote:[https://skilldrick.github.io/easyforth/#defining-words]
  footnote:[https://users.ece.cmu.edu/~koopman/forth/hopl.html]
On the other hand, factor has clear documentation discussing its syntax.
  footnote:[https://docs.factorcode.org/content/article-parser-algorithm.html]
  footnote:[https://docs.factorcode.org/content/article-syntax-literals.html]


## Denotational semantics


### Informal definitions

* Dictionary
* Atoms/Elements:
** Booleans
** Characters
** Numbers
* Arrays
** Bitarrays
** Strings
** Vectors
** Matrixes

### Formal definitions

#### Strings



#### Kernel

[graphviz]
----
digraph D {
  input ->
"\"open quote" -> "\"close quote"
  -> string
  input ->
"\'open quote" -> "\'close quote"
  -> string  
  input ->
"\[open bracket" -> "\]close bracket"
  -> array  
  input ->
"\" \"open space" -> "\" \"close space"
  -> word  
}
----

image:https://kroki.io/graphviz/svg/eNp1zkEKwjAUhOF9TzFk05VXcOUtWhfPNLTBksSXBBHp3X2YRKji9mc-mMnOTGHBCc8OsC7khMOxU6PywTjcsk9GSYEUvfpoapKxxJjYunkP-x_Y_4PAng5vemHSV5MqPhfcYuHETI9vrVBPx0D6cxrtd6nF3z1PwrcX9XhK3Q==[]

[ditaa]
----

Word being defined
+-------------------------+
| : add5 ( x -- x ) 5 + ; | 
+-------------------------+
|
| Access primitives dictionary
|
v
+---------------------------+
| Primitives Dictionary...  |
+---+---+---+---+---+---+---+
| 1 | 2 | 3 | 4 | 5 | + | - |
+---+---+---+---+---+---+---+
|
| Expand word and add to dictionary
| 
v
+--------------+
| Dictionary...|
+-------+------+
| add 5 | 5  + |
+-------+------+

----

image:https://kroki.io/ditaa/svg/eNqFkD8LwjAQxfd-ijcqIQX_ZNFJ0N3Nufai3GBa2lAr5MN7qdBSSuvBOzK8393L3YqKcLfsniD7YGcpUXquVBJwQEZksEILraWtYaBwRMAyKOgpz21do6z4xZ4bW4M491y4rPqIoVkY8Nt9HchzT6ZpCoSOnZWwG0m4Fe1Ee5ERKZH-zwp9acvMEd7xWvEhN4AvRvkx_UDcOwoaeocaHHGW6RLFQFPHFyfUZU4=[]


# <<Waterfall>> process

. Integration Requirements
. Feature Design
. Properties
. Specification
. Implementation
. Verification
. Maintenance 



[bibliography]
= References

* [[[Hoare]]] https://en.wikipedia.org/wiki/Hoare_logic#Hoare_triple
* [[[Waterfall]]] https://en.wikipedia.org/wiki/Waterfall_model#Model
* [[[Dependent]]] https://en.wikipedia.org/wiki/Dependent_type
* [[[factor]]] https://github.com/factor/factor/
* [[[APL]]] https://tryapl.org/
* [[[pharo]]] https://github.com/pharo-project/pharo
* [[[r4]]] https://github.com/phreda4/r4
* [[[chainsaw]]] The Unix shell is sometimes referred to as a chainsaw (see `rm -rf *`)
* [[[simplex]]] https://www.infoq.com/presentations/Simple-Made-Easy/

+++
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This README is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.
+++
